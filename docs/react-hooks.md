# React Hooks
React コンポーネントが画面に表示されてから、消えるまでの一連の過程のことをライフサイクルと呼ぶ


## useEffect
コンポーネントが画面に表示されるとき、表示自体以外の追加作業を行うためにuseEffectが利用される
### 副作用とは
Reactのコンポーネントの主な仕事(画面に何かを表示すること)以外の追加の作業や影響のことを指す
→インターネットからのデータの取得、ユーザーの操作に応じた画面の変更、リアルタイムでの情報更新など
　コンポーネントのメインの機能表示とは別に行う作業のこと

### クリーンアップ関数
画面からコンポーネントが消えた時に実行される関数
→ タイマーやイベントリスナーなどの処理は使い終わったらそれを止めるクリーンアップ関数を書くことでメモリの無駄づかいを防げる
→ クリーンアップ関数は全ての実装に必要なわけではない
→ 継続的な処理かどうかが1つの判断基準となる
1. コンポーネントのアンマウント時
2. 依存配列の値が変更されて、effectが再実行される前
3. 次のレンダリングで新しいeffectが実行される前
```ts
useEffect(() => {
  // 副作用の処理
  return () =>{
    // クリーンアップ関数
  }
})
```

## useRef
作った変数の値が更新されても再レンダリングされない
画面更新の必要はないが、裏側でデータを保持しておきたい時に利用する


```ts
const 変数 = useRef(初期値);

const ref = const ref = useRef(0);

```

### .currentの使い方
useRefを利用するとデータは.currentプロパティに保管される

```ts
console.log(ref.current); // 0
useRef(0);

# 直接値の更新も可能　再レンダリングはされない
ref.current = 1;
```

### やってはいけない実装
* useEffectの依存配列にrefを利用する
```ts
const ref = useRef(0);

useEffect(() => {
  console.log(ref.current);
}, [ref.current]); // 👈 ref.currentが更新されてもuseEffectの関数は再実行されない
```

* 描画のための値をuseRefで保持する
useRefは.currentを更新しても再レンダリングされない












